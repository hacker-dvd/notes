### 通过树状数组求解最长上升子序列问题

树状数组的好处：同样在 O(nlogn) 的时间内，我们可以求出以每个下标结尾的最长上升子序列的值为多少。

基本思想：考虑朴素的 dp 做法：

```c++
for (int i = 1; i <= n; ++i) {
    for (int j = 1; j < i; ++j) {
        if (a[j] < a[i]) {
            dp[i] = std::max(dp[i], dp[j] + 1);
        }
    }
}
```

我们在从前往后枚举 i 的时候，每次相当于在满足：

1. 下标值小于等于 i
2. 高度值小于 a[i]

的所有点中找到一个以该点结尾，且有着最长上升子序列最长的点，这实际上是一个区间查询的过程。

然后找到满足要求的最长子序列之后，我们需要将 i 号点的最长上升子序列的值更新，以供后续计算使用，这实际上是一个单点修改的问

题。

我们可以使用树状数组来优化单点修改，区间查询这一过程。

我们先将所有的点的高度和编号值存储在一个结构体中，然后将结构体以高度为关键字进行排序。



